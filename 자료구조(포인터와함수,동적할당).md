# 자료구조 스터디

유튜브 박동규 교수님의 널널한 박교수의 C프로그래밍 고급편으로 스터디 진행함

![널널한 박교수의 C언어 고급편](https://youtu.be/yV1gplHtXiM)

(인프런에도 강의가 있다 ㅎㅎ)



## 포인터와 함수



C언어는 하나 이상의 함수로 구성되며, 모듈화작업을 통해서 개별작성된 함수를 통합시키는 방식으로 큰 프로그램을 편리하게 개발할 수 있다. 본 강의에서는 함수의 사용법과 포인터변수를 사용하여 피호출함수가 호출함수의 변수에 접근하는 방법을 살펴본다.


### 함수와 매개변수


- 함수 : 특정한 작업을 수행하는 독립적인 부분으로, 재사용을 통해 코드의 중복을 줄여준다.
- 모듈화 작업을 통해서 개별작성된 함수를 통합시키는 방식으로, 큰 프로그램을 개발할 수 있다.
- 개발과정이 보다 쉬워지며, 유지보수도 쉬워진다.
- 함수 선언, 함수 구현, 호출의 형태로 이루어짐.
- 매개변수를 통해서 값을 전달하며 return은 하나의 값을 반환한다.


```c
#include <stdio.h>

// 함수 선언
//int sum(int a, int b);
// 다음과 같은 형태도 가능함
int sum(int, int);

int main(int argc, const char * argv[]) {

    int n = 10, m = 20;
    // 함수 호출
    printf("%d과 %d의 합은 %d \n",n,m,sum(n,m));
    int res = sum(100, 200);
    printf("res = %d\n", res);
    return 0;
}

// 함수의 구현 - a,b를 매개변수로 받아서 그 합을 반환함
int sum(int a, int b)
{
    int result = a + b;
    return result;
}
```

### 값에 의한 호출 (call by value)

- C의 함수호출시 피호출함수의 매개변수는 호출하는 함수가 전달하는 값(value)을 복사받는다.
- 피호출함수는 루틴을 실행한 후, **return 키워드**를 통해서 호출함수에 결과값을 전달한다.
- return 키워드는 단 하나의 값만을 전달할 수 있다.
- 피호출함수 내에서 변경된 값이 여러개 있을 경우라도 하나밖에 전달할 수 없음

#### 변수의 주소를 전달한다.

포인터를 이용하면 피호출함수에 변수의 **주소**를 전달할 수 있다.

피호출함수는 전달된 주소를 받은 포인터 변수를 통해서, 간접적인 방식으로 호출 함수의 변수값을 변경해줄 수 있음.

코드로 봐보면,


```c
#include <stdio.h>

void changeNum(int n);

int main(int argc, const char * argv[]) {
    
    int num = 10;
    // 함수 호출
    printf("num = %d\n", num);
    changeNum(num);
    printf("changeNum()의 결과 \n");
    printf("num = %d\n", num);
    return 0;
}

// changeNum 함수의 구현 - n을 20으로 수정
void changeNum(int n)
{
    n = 20;
}

```

간단한 코드기는 하지만, 호출과정이 어떻게 되는지 그림으로 한번 봐보자.


![과정1](https://image.slidesharecdn.com/4-160719065136/95/4-45-638.jpg?cb=1517407049)
![과정2](https://image.slidesharecdn.com/4-160719065136/95/4-48-638.jpg?cb=1517407049)

포인터 ptr 값이 변경되고 changeNum() 함수는 종료된다.


### Swap 함수

- 두 변수값을 교환하는 기능
- 포인터를 사용하지 않을 경우 변수값 교환이 어려움
- 포인터를 사용하여 여러개의 변수값을 변경할 수 있음


```c
#include <stdio.h>
void swap(int x, int y);

int main(void)
{
    int a = 100, b = 200;
    
    printf("a=%d b=%d\n",a, b);
    swap(a, b);
    printf("a=%d b=%d\n",a, b);
    
    return 0;
}

void swap(int x, int y)
{
    int tmp;
    
    printf("swap() x=%d y=%d\n",x, y);
    tmp = x;
    x = y;
    y = tmp;
    printf("swap() x=%d y=%d\n",x, y);
}
```

```c
출력 결과

a=100 b=200
swap() x=100 y=200
swap() x=200 y=100
a=100 b=200
```

피호출함수 px, py는 main()함수 내 a,b변수의 주소값을 가지는 포인터 변수이다.

이 포인터 변수를 통해 피호출함수가 호출함수의 값을 바꿀 수 있다.



## 포인터와 배열



C언어에서 배열은 포인터변수를 이용하여 접근 가능합니다. 따라서 포인터는 배열처럼 사용가능하며, 인덱스 표기법을 포인터에 사용할 수 있습니다.
이 장에서는 배열과 포인터에 대해 예제코드를 통해 배워봅니다.


### 배열

배열은? 동일한 타입의 데이터가 여러개 저장되어 있는 데이터 저장장소다.
- 저장장소의 이름은 배열명이 되며, 저장된 데이터는 인덱스에 의해 참조한다.

C언어에서 배열은 포인터 변수를 이용하여 접근이 가능하다.

- 포인터는 배열처럼 사용이 가능하며, 인덱스 표기법을 포인터에 쓸 수 있다.
- int a[10]에서 배열명 a는 배열 첫번째 객체 a[0]을 가리키는 포인터 변수와 같다.

![배열 설명](https://image.slidesharecdn.com/6-160719065640/95/6-32-638.jpg?cb=1517409668)



## 동적 메모리 할당



동적 메모리할당을 보기 전에 정적 메모리할당을 먼저 살펴보자.

### 정적 메모리 할당

- 프로그램이 시작되기 전에 미리 정해진 크기의 메모리를 할당 받는것을 말한다.
    - int num, char str[256]; 등등..
- 처음에 결정된 크기의 값만을 처리한다.
- int a[1000]; 과 같은 배열은 1000개의 정수값만을 배열에 넣을 수 있으며, 1개의 값만이 배열에 있을 경우 메모리 낭비가 발생한다.


```c
#include <stdio.h>

int main(void) {
    int n[1000];

    n[0] = 10;

    printf("n[0] = %d\n", n[0]);
    // n[1]...n[999] 까지의 메모리는 할당되었으나 사용되지 않음.

    return 0;
}
```


### 동적 메모리 할당

- 프로그램의 실행 도중에 메모리를 할당 받는 것
- 운영체제의 힙 영역의 메모리를 할당받아서 사용함
- 메모리 낭비가 적어 효율적이다.
- 운영체제에 프로그램이 필요로 하는 **메모리의 용량을 알려줘야 한다.** 또는 **할당된 메모리의 주소**를 알아야 사용할 수 있다.
    - C언어는 이를 위해 malloc() 함수를 쓴다.
    - malloc() 함수의 반환값 : 할당된 메모리의 주소값

![동적메모리할당1](https://image.slidesharecdn.com/5-160719065244/95/5-13-638.jpg?cb=1484294334) 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int *ip;
    double *dp;

    // 동적으로 int, double 자료형 크기의 메모리를 할당받음
    ip = (int *)malloc(sizeof(int));
    dp = (double *)malloc(sizeof(double));

    // 할당된 메모리 공간에 값을 넣는다.
    *ip = 10;
    *dp = 3.4;

    printf("정수형 포인터 변수의 값 : %d\n", *ip);
    printf("실수형 포인터 변수의 값 : %lf\n", *dp);

    return 0;
}
```   

```c
출력 결과

정수형 포인터 변수의 값 : 10
실수형 포인터 변수의 값 : 3.400000
```


### 힙(Heap) 메모리


힙(Heap)영역 : 메모리를 프로그램이 실행되는 동안 동적으로 결정하는 경우 사용되는 공간

![heap memory](https://image.slidesharecdn.com/5-160719065244/95/5-23-638.jpg?cb=1484294334)


힙 영역에 동적으로 생성된 객체는 프로그램 실행중에 소거될 수 있다.

![heap memory2](https://image.slidesharecdn.com/5-160719065244/95/5-24-638.jpg?cb=1484294334)


#### 비고 : 메모리의 구조


![출처는 여기서-TCP school](http://tcpschool.com/c/c_memory_structure)

![메모리 구조](http://tcpschool.com/lectures/img_c_memory_structure.png)


1. 코드(code)영역

메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.
CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.


2. 데이터(data)영역

메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.
데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.


3. 스택(stack)영역

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.
이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.
이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.
스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.


4. 힙(heap)영역

메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역입니다.
힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.


### malloc() 함수

> void* malloc (size_t size);

- size : 바이트 값
- malloc() 함수는 할당된 메모리 블럭의 **첫번째 바이트에 대한 주소**를 반환한다.
- 메모리를 할당할 수 없을 경우, **NULL**을 반환한다.
- malloc() 함수가 반환한 값은 반드시 **포인터 변수**가 받아야 한다.


### free() 함수

- 동적으로 할당된 메모리의 블럭이 사용이 종료되면 이 블럭을 시스템에 반납하여야 한다
- 사용하지 않으면서 반납되지 않은 메모리 블럭이 자꾸 발생하게 되면 시스템의 성능이 저하된다.
    - 이를 **메모리 누수(leak)현상** 이라고 한다.
    - 사용되지 않는 메모리 블럭을 **가비지(garbage) 메모리** 라고 한다.
- free() 함수를 통해 반납한다.
- free() 함수는 동적으로 할당된 메모리 블럭에 대한 포인터를 매개변수로 취한다.


```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int i, size = 3;
    double value, total=0.0;
    double *scores;
    scores = (double *)malloc(size*sizeof(double));
    
    for(i=0;i<size;i++) {
        printf("성적을 입력하시오 : ");
        scanf("%lf", &value);
        *(scores+i) = value;
        {
        }
    }
   
    for(i=0;i<size;i++){
       total += scores[i];
    }

    printf("평균: %f\n", total/size);
    free(scores);
    return 0;
}
```    

```c
출력 결과

성적입력 : 10
성적입력 : 20
성적입력 : 30
평균 : 20.000000
```